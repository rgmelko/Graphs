<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Graphs by rgmelko</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/rgmelko/Graphs">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/rgmelko/Graphs/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/rgmelko/Graphs/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Introduction to Graphs</h1>
          <p></p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/rgmelko">rgmelko</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>

<h1>Why use graphs?</h1>

<p>The numerical linked cluster expansion involves approximating the value of some extensive quantity on an infinite lattice by using a weighted sum of graphs. But what does this mean? How is a graph defined, and which graphs should be used in this weighted sum? </p>

<h2>Graph definition</h2>

<p> A graph is defined as a collection of points (usually called vertices in the graph theory literature) and lines connecting them (edges). Since we are interested in a quantum model on a lattice, we restrict ourselves to considering only those graphs which are embeddable in the infinite lattice. For instance, if we were considering the square lattice, we would not use any graphs with triangles included (in the graph theory terminology, 3-cycles). If we considered the Kagome lattice, any graph containing a square wouldn't be useful to us. Some Hamiltonians are direction "agnostic", and some are not - for some Hamiltonians, it matters if (for a line), the line points in the <i>x</i> direction or the <i>y</i> direction. So the set of graphs we use will depend both on the lattice and the model we are interested in studying. </p>

<h1> Types of Graphs</h1>

Depending on the situation, different physical interactions may be dominant in a lattice. In particular, sometimes <i>site-based</i> effects, like the alignment of a spin with an external magnetic field, are more important for the physics of a system, while other times <i>bond-based</i> effects, like an Ising interaction across a connection between spins, is more important. We have two types of graph, each tailored to one of these situations.

<h2>Site based graphs</h2>

<p> Graphs are called site-based if they are primarily defined by the positions of their vertices - if two vertices are placed adjacently in real space (for instance, in the square lattice, if we had vertices at (0,0) and (0,1)) then they are assumed to be connected by an edge (or bond). If we had a "square" made of 4 sites, then each site would have to be connected to two neighbours. Site based graphs can be generated by picking a "primitive" graph to start from - one bare site works well - and then checking every possible position where a new site could be added. If we can't add a new site in this position, we just continue to the next. If we can add a site, we do so and check to see if this graph's already been generated. We'll discuss how this is done in a bit. </p>

<h2>Bond based graphs</h2>

<p> Graphs are called bond-based if they are primarily defined by the positions of their edges - if two vertices are placed adjacently in real space (for instance, in the square lattice, if we had vertices at (0,0) and (0,1)) then they are not assumed to be connected by an edge (or bond). Instead, we specify the graph by listing the bonds it contains, using their endpoints. If we had a "square" made of 4 sites, then there are a variety of possible Graphs. Each site could be connected to two neighbours, or we could have two sites with only one neighbour (forming a kind of "U" shape). Bond based graphs can also be generated by picking a "primitive" graph to start from - one bond works well - and then checking every possible position and direction combination where a new bond could be added. If we can't add a new bond in this position/direction, we just continue to the next. If we can add a bond, we do so and check to see if this graph's already been generated. We do this through the power of canonical labelling.</p>

<h1> Selecting Graphs </h1>

Now that we know how to describe two different types of lattice graphs, it would be nice to be able to tell which graphs are going to give the same Hamiltonian and avoid having copies. This will save time when making the graphs and when doing physics calculations on them. 

<h2>Canonical Labelling and the Graph Key</h2>

<p> Since we'll need to consider many graphs in our physical simulation, it would be nice to be able to avoid using graphs which are really duplicates of each other (they have the same Hamiltonian). Is there a way to find a "unique" represention of each graph so that we can convert every graph to this representation, then compare these to get rid of duplicates? It turns out there is. Every graph has at least one distinct representation (here, we choose this to mean that distinct representations are at least not superimposable over each other). We can order the representations of the graph by doing <a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical comparison</a> on their site or bond lists. Then, we pick the smallest or largest graph (in our case we pick the largest). This representation is unique. We'll never be able to generate a canonical graph from a noncaonical graph (you can look in the graph theory literature for a proof of this), so we simply put all graphs in their canonical form and then remove duplicates. </p>

<h2>Isomorphism</h2>

<p> In the last section we mentioned <i>representations</i> of graphs, but what does this mean exactly? How do we decide whether two lists of sites/bonds describe the same graph? We need to find the set of graphs which are isomorphic to a certain graph. The set of transformations that we can use to check isomorphism. For Hamiltonians which are direction-agnostic (like the transverse field Ising model), we can simply use the <a href="http://en.wikipedia.org/wiki/Dihedral_group">dihedral group</a> of the lattice, which is the set of rotations and reflections in the lattice (so the square lattice has a dihedral group with eight elements). But other Hamiltonians might have groups of transformations that are smaller. We say that two graphs are isomorphic if applying one of the transformations discussed before makes one graph superimposable on the other and the graphs have the same number of elements (sites or bonds). </p> 
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
